---
title: "test"
author: "Nick McManus"
date: "2023-07-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)    ## always
library(here)         ## consistent file paths
library(stringr)      ## split up file names
library(lubridate)    ## mutate dates
library(terra)        ## better/faster GIS package
library(sf)           ## format plays nicer w/leaflet
library(raster)       ## format plays nicer w/leaflet
library(leaflet)      ## test interactive maps
```


## DATA WRANGLING

In this section, we'll crop and reproject spatial data as well as find zonal statistics and output dataframes useful for the Shiny.



### Zip codes

We want to find and save the zip codes that intersect with Kern county. This .shp will then be exported for use in the Shiny app.

*Note*: For the purposes of this app, the extent of zip codes will be cropped to only portions within Kern county. To keep the entire geometry of zips that are within Kern, see the commented out code chunk below. 

```{r}
## Read in raw data using 'sf' package
zips <- st_read(here('data/zipcodes/CA_Zips.shp'))
counties <- st_read(here('data/counties_ca/cnty19_1.shp'))

## make sure both layers have same crs
zips_reproj <- zips %>% 
  st_transform(zips, crs = st_crs(counties)) %>% 
  ## only need to keep zip code number
  dplyr::select(GEOID10) %>% 
  ## remove incorrect zip
  dplyr::filter(!GEOID10 == 93453) %>%
  ## transform to SpatVect obj in `terra` pkg
  vect()

## isolate Kern county
kern <- counties %>%
  dplyr::filter(COUNTY_NAM == "Kern") %>%
  dplyr::select(COUNTY_NAM) %>% 
  ## make SpatVect obj
  vect() %>% 
  ## need buffer to remove very small portions
  ## of zip codes that remain at edges of county
  buffer(width = -35)

## clip zips to kern county
kern_zips <- terra::intersect(kern, zips_reproj)

## make CRS leaflet friendly
kern_zips <- terra::project(kern_zips, "+proj=longlat +datum=WGS84")

## Save clipped zips
writeVector(kern_zips, here('data/zipcodes/kern_zips.shp'), overwrite = T)

```


```{r}
# ## Read in raw data
# zips <- st_read(here('data/zipcodes/CA_Zips.shp'))
# counties <- st_read(here('data/counties_ca/cnty19_1.shp')) 
# 
# ## make sure both layers have same crs
# zips_trans <- zips %>% 
#   st_transform(zips, crs = st_crs(counties)) %>%
#   ## only need to keep zipcode number
#   dplyr::select(GEOID10) 
# 
# ## Only keep name of counties
# counties <- dplyr::select(counties, COUNTY_NAM)
# 
# # kern <- dplyr::filter(counties, COUNTY_NAM == "Kern") 
# 
# 
# ## Keep zipcodes that touch Kern county
# kern_zips <- st_join(zips_trans, counties, join = st_intersects) %>% 
#   dplyr::filter(COUNTY_NAM == "Kern", 
#                 ## remove select zips that barely touch Kern
#                 !GEOID10 %in% c(93536, 93535, 93201, 
#                                 93239, 93204, 93453,
#                                 93257, 93260, 93219, 
#                                 93261, 93218)) 
#   
# ## Reproject zips to leaflet-required crs
# kern_zips_trans <- st_transform(kern_zips, crs = "+proj=longlat +datum=WGS84")
# 
# ## save
# st_write(kern_zips_trans, here("data/zipcodes/kern_zips.shp"))

```


### Standing water

Here we'll run zonal stats to determine how much standing water is present in each zip code. This information will be exported as a .csv and used for the Shiny app. To do this, we'll need to first ensure that our `kern_zips.shp` are the same crs as the water rasters. Then we'll use a function to loop through all the water rasters within the directory.
```{r}
## Create list of all water rasters in directory
filenames <- list.files(path="data/water/Landsat_Dan/", pattern=".TIF")

## Extract dates for each based on LANDSAT naming convention.
## Split up name by underscores, return as own column in df
dates <- str_split(filenames, "_", simplify = TRUE) %>% 
  as.data.frame() %>% 
  mutate(date = lubridate::ymd(V4)) %>% 
  dplyr::select(date)


## Need same crs for zonal stats.
## Easier to transform vector than the high-res raster
ex_rast <- rast(here('data/water/Landsat_Dan', filenames[1]))
names(ex_rast) <- "rast"
kern_zips <- vect(here("data/zipcodes/kern_zips.shp")) %>% 
  project(y = crs(ex_rast))


## Function to perform zonal stats and output results
water_stats <- function(water_rast, zip_vect, rast_date) {
  zonal_stat <- terra::zonal(water_rast, zip_vect, fun = 'sum', na.rm = TRUE)
  
  zonal_stat_df <- zonal_stat %>% 
    ## assign values with corresponding zipcode
    mutate(zipcode = zip_vect$GEOID10) %>% 
    ## convert values from # of pixels to acres
    ## w/30m resolution, each pixel is 900 m^2
    ## 4046.86 m^2 are in one acre
    rename(water_acres = "rast") %>% 
    mutate(water_acres = water_acres * 900 / 4046.86) %>% 
    ## finally, add date image was taken
    mutate(date = rast_date)
}

## empty df to store results  
zip_water_df <- data.frame()

  ## Loop through each raster and add zonal stats to df
for (i in 1:length(filenames)) {
  ## read in raster  
  r <- rast(here('data/water/Landsat_Dan', filenames[i]))
  names(r) <- "rast"
  
  ## find zonal stats using above fxn
  r_stats <- water_stats(r, kern_zips, dates[i,])
  
  ## append df w/raster stats
  zip_water_df <- rbind(zip_water_df, r_stats)
}


## export as .csv
write_csv(zip_water_df, here('data/water/water_acre_zipcode.csv'))
```

### Transmission efficiency

Here we'll find an average WNV transmission efficiency for each zipcode.
```{r}
wnv_risk <- rast(here('data/Kern_transmission_raster_wgs84.tif'))

## easier to transform vector than high-res raster
kern_zips <- vect(here("data/zipcodes/kern_zips.shp")) %>% 
  project(y = crs(wnv_risk))

## find the mean value per zip
risk_zonal <- terra::zonal(wnv_risk, kern_zips, fun = 'mean', na.rm = T)

risk_zonal_zips <- risk_zonal %>% 
  mutate(zipcode = kern_zips$GEOID10) %>% 
  rename(trans_risk = Kern_transmission_raster_wgs84)

write_csv(risk_zonal_zips, here('data/transmission_zipcodes.csv'))
```



### Trap data

Finally, we'll wrangle some trap data and aggregate it by zip code. Exact locations of traps should not be public, so instead we'll produce plot showing how number of WNV found in traps across a zipcode changes by month/year.
```{r}
## Read in raw trap data
traps <- st_read(here('data/wnv_cases/WNV_full_4_23_CA.shp'))

zips_kern <- st_read(here("data/zipcodes/kern_zips.shp"))

## make same crs and into terra vectors
zips_kern <- st_transform(zips_kern, crs = st_crs(traps)) %>% 
  vect()
traps <- vect(traps)


## Find intersection using terra (much faster) then
## convert back to sf to save as csv
traps_kern <- terra::intersect(zips_kern, traps)
traps_kern_sf <- st_as_sf(traps_kern)
## Save intermediate
# st_write(traps_kern_sf, here('data/wnv_cases/wnv_kern.shp'))
# write_csv(traps_kern_sf, here('data/wnv_cases/wnv_kern.csv'))


## Now filter data and create test plots
cases_kern <- read_csv(here('data/wnv_cases/wnv_kern.csv')) %>% 
  janitor::clean_names()

cases_zip_yr <- cases_kern %>% 
  filter(geoid10 == 93203) %>% 
  group_by(year) %>% 
  summarize(cases = sum(count))


ggplot(data = cases_zip_yr, aes(x = year, y = cases))+
  geom_point(color = "sienna2", size = 3, alpha = 0.6) +
  geom_line(linewidth = 1, color = "sienna4") +
  labs(y = "Annual cases",
       x = element_blank()) +
  theme_classic() +
  theme(
    # axis.title.x = element_text(face = "bold", vjust = -1),
    axis.title.y = element_text(face = 'bold', vjust = 3)
  )

cases_zip_yr_mo <- cases_kern %>% 
    ## user input ex
  filter(geoid10 == 93252) %>% 
  filter(month == "Aug") %>% 
  group_by(year) %>% 
  summarize(cases = sum(count)) 

ggplot(data = cases_zip_yr_mo, aes(x = year, y = cases))+
  geom_point(color = "sienna2", size = 3, alpha = 0.6) +
  geom_line(linewidth = 1, color = "sienna4") +
  labs(y = "Cases by month",
       x = element_blank()) +
  theme_classic() +
  theme(
    # axis.title.x = element_text(face = "bold", vjust = -1),
    axis.title.y = element_text(face = 'bold', vjust = 3)
  )
```









## TEST PLOTS



Testing out water plot for shiny:
```{r}
data <- read_csv(here('data/water/water_test_data.csv'))

user_input <- "93222"

data_filtered <- data %>% 
  filter(zipcode == user_input) %>% 
  mutate(date = mdy(date))


ggplot(data_filtered, aes(x = date, y = water_ha)) +
  geom_point(color = "dodgerblue3", size = 4, alpha = 0.6) +
  geom_line(size = 0.6, color = "dodgerblue4") +
  labs(y = "Surface water size (ha)",
       x = element_blank()) +
    ## customize axis with cont 'date' class data
  scale_x_date(limits = as.Date(c('2023-05-07', '2023-06-25')),
               date_breaks = "1 week",
               date_labels = "%b %d") +
  theme_classic() +
  theme(
    # axis.title.x = element_text(face = "bold", vjust = -1),
    axis.title.y = element_text(face = 'bold', vjust = 3)
  )
```






```{r}
water <- raster(here('data/water/time_series/LC09_CU_003011_20230625_20230701_02_DSWE_Binary2_T.tif'))
water_reproj <- projectRaster(water, crs = crs(trans_r), method = 'ngb')
names(water_reproj) <- "water_reproj"
water_reproj[water_reproj == 0] <- NA

writeRaster(water_reproj, here('data/water/water_reproj.tif'))
```


Testing leaflet outside of Shiny app

```{r}
wnv_risk <- raster(here('data/Kern_transmission_raster_wgs84.tif'))

pal <- colorNumeric(palette = 'viridis', domain = values(wnv_risk),
                    reverse = TRUE,
                    na.color = "transparent")


zips <- read_sf(here("data/zipcodes/kern_zips.shp"))

leaflet() %>% 
  ## Add background maps
  addTiles(group = "OpenStreetMaps") %>% 
  addProviderTiles(providers$Stamen.TonerLite, group = "Toner Lite") %>%
  ## Add rasters
  addRasterImage(wnv_risk, colors = pal, project = FALSE, group = "WNV Risk") %>%
  # addRasterImage(water_reproj, colors = 'dodgerblue4', project = FALSE, group = "Water") %>% 
  ## Add polygons
  addPolygons(data = zips, color = "#343434", 
              weight = 2, fillOpacity = 0.2,
              label = paste0("Zip code: ", zips$GEOID10),
              group = "Zip codes",
              highlightOptions = highlightOptions(weight = 5,
                                               color = "white",
                                               bringToFront = TRUE)) %>% 
  ## Add groups to map
  addLayersControl(
    baseGroups = c("OpenStreetMaps", "Toner Lite"),
    overlayGroups = c("WNV Risk", "Zip codes", "Water"),
    options = layersControlOptions(collapsed = T),
    position = "topleft"
  ) %>% 
  hideGroup("Zip codes") %>% 
  ## Add legend to map
  addLegend(pal = pal, values = values(wnv_risk),
            "bottomleft",
            title = "WNV Transmission Risk")%>% 
      setView(-119.3, 35.55, zoom = 11)

```

